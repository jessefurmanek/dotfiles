"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
/**
 * Returns a Generator that walks most of the AST (the part that matters for gathering all references) and emits Nodes
 *
 * TODO is this function worth it?
 */
function* walkMostAST(node) {
    yield node;
    // TODO don't maintain an array
    const children = [];
    switch (node.kind) {
        case ts.SyntaxKind.QualifiedName: {
            const n = node;
            children.push(n.left, n.right);
            break;
        }
        case ts.SyntaxKind.ComputedPropertyName: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.TypeParameter: {
            const n = node;
            pushall(children, n.name, n.constraint, n.expression);
            break;
        }
        case ts.SyntaxKind.Parameter: {
            const n = node;
            pushall(children, n.name, n.type, n.initializer);
            break;
        }
        case ts.SyntaxKind.Decorator: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.PropertySignature: {
            const n = node;
            pushall(children, n.name, n.type, n.initializer);
            break;
        }
        case ts.SyntaxKind.PropertyDeclaration: {
            const n = node;
            pushall(children, n.name, n.type, n.initializer);
            break;
        }
        case ts.SyntaxKind.MethodSignature: {
            const n = node;
            pushall(children, n.name, n.type);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            if (n.parameters) {
                children.push(...n.parameters);
            }
            break;
        }
        case ts.SyntaxKind.MethodDeclaration: {
            const n = node;
            pushall(children, n.name, n.body);
            break;
        }
        case ts.SyntaxKind.Constructor: {
            const n = node;
            pushall(children, n.name, n.body);
            break;
        }
        case ts.SyntaxKind.GetAccessor: {
            const n = node;
            children.push(n.name, n.body);
            break;
        }
        case ts.SyntaxKind.SetAccessor: {
            const n = node;
            children.push(n.name, n.body);
            break;
        }
        case ts.SyntaxKind.CallSignature: {
            const n = node;
            pushall(children, n.name, n.type);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            if (n.parameters) {
                children.push(...n.parameters);
            }
            break;
        }
        case ts.SyntaxKind.ConstructSignature: {
            const n = node;
            pushall(children, n.name, n.type);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            if (n.parameters) {
                children.push(...n.parameters);
            }
            break;
        }
        case ts.SyntaxKind.IndexSignature: {
            const n = node;
            pushall(children, n.name, n.type);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            if (n.parameters) {
                children.push(...n.parameters);
            }
            break;
        }
        case ts.SyntaxKind.TypePredicate: {
            const n = node;
            children.push(n.parameterName, n.type);
            break;
        }
        case ts.SyntaxKind.TypeReference: {
            const n = node;
            children.push(n.typeName);
            if (n.typeArguments) {
                children.push(...n.typeArguments);
            }
            break;
        }
        case ts.SyntaxKind.ConstructorType:
        case ts.SyntaxKind.FunctionType: {
            const n = node;
            pushall(children, n.name, n.type);
            pushall(children, n.name, n.type);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            if (n.parameters) {
                children.push(...n.parameters);
            }
            break;
        }
        case ts.SyntaxKind.TypeQuery: {
            const n = node;
            children.push(n.exprName);
            break;
        }
        case ts.SyntaxKind.TypeLiteral: {
            const n = node;
            pushall(children, n.name);
            children.push(...n.members);
            break;
        }
        case ts.SyntaxKind.ArrayType: {
            const n = node;
            children.push(n.elementType);
            break;
        }
        case ts.SyntaxKind.TupleType: {
            const n = node;
            children.push(...n.elementTypes);
            break;
        }
        case ts.SyntaxKind.IntersectionType:
        case ts.SyntaxKind.UnionType: {
            const n = node;
            children.push(...n.types);
            break;
        }
        case ts.SyntaxKind.ParenthesizedType: {
            const n = node;
            children.push(n.type);
            break;
        }
        case ts.SyntaxKind.LiteralType: {
            const n = node;
            children.push(n.literal);
            break;
        }
        case ts.SyntaxKind.ObjectBindingPattern:
        case ts.SyntaxKind.ArrayBindingPattern: {
            const n = node;
            children.push(...n.elements);
            break;
        }
        case ts.SyntaxKind.BindingElement: {
            const n = node;
            pushall(children, n.propertyName, n.name, n.initializer);
            break;
        }
        case ts.SyntaxKind.ArrayLiteralExpression: {
            const n = node;
            children.push(...n.elements);
            break;
        }
        case ts.SyntaxKind.ObjectLiteralExpression: {
            const n = node;
            children.push(...n.properties);
            break;
        }
        case ts.SyntaxKind.PropertyAccessExpression: {
            const n = node;
            children.push(n.expression, n.name);
            break;
        }
        case ts.SyntaxKind.ElementAccessExpression: {
            const n = node;
            pushall(children, n.expression, n.argumentExpression);
            break;
        }
        case ts.SyntaxKind.CallExpression: {
            const n = node;
            pushall(children, n.name, n.expression, ...n.arguments);
            if (n.typeArguments) {
                children.push(...n.typeArguments);
            }
            break;
        }
        case ts.SyntaxKind.NewExpression: {
            const n = node;
            if (n.name) {
                yield* walkMostAST(n.name);
            }
            yield* walkMostAST(n.expression);
            if (n.arguments) {
                for (const argument of n.arguments) {
                    yield* walkMostAST(argument);
                }
            }
            if (n.typeArguments) {
                for (const typeArgument of n.typeArguments) {
                    yield* walkMostAST(typeArgument);
                }
            }
            break;
        }
        case ts.SyntaxKind.TaggedTemplateExpression: {
            const n = node;
            children.push(n.tag, n.template);
            break;
        }
        case ts.SyntaxKind.TypeAssertionExpression: {
            const n = node;
            children.push(n.type, n.expression);
            break;
        }
        case ts.SyntaxKind.ParenthesizedExpression: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.FunctionExpression: {
            const n = node;
            pushall(children, n.name, n.body);
            break;
        }
        case ts.SyntaxKind.ArrowFunction: {
            const n = node;
            children.push(n.body);
            break;
        }
        case ts.SyntaxKind.DeleteExpression: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.TypeOfExpression: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.VoidExpression: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.AwaitExpression: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.PrefixUnaryExpression: {
            const n = node;
            children.push(n.operand);
            break;
        }
        case ts.SyntaxKind.PostfixUnaryExpression: {
            const n = node;
            children.push(n.operand);
            break;
        }
        case ts.SyntaxKind.BinaryExpression: {
            const n = node;
            children.push(n.left, n.right);
            break;
        }
        case ts.SyntaxKind.ConditionalExpression: {
            const n = node;
            children.push(n.condition, n.whenTrue, n.whenFalse);
            break;
        }
        case ts.SyntaxKind.TemplateExpression: {
            const n = node;
            children.push(n.head, ...n.templateSpans);
            break;
        }
        case ts.SyntaxKind.YieldExpression: {
            const n = node;
            pushall(children, n.expression);
            break;
        }
        case ts.SyntaxKind.SpreadElement: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.ClassExpression: {
            const n = node;
            pushall(children, n.name, ...n.members);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            if (n.heritageClauses) {
                children.push(...n.heritageClauses);
            }
            break;
        }
        case ts.SyntaxKind.ExpressionWithTypeArguments: {
            const n = node;
            children.push(n.expression);
            if (n.typeArguments) {
                children.push(...n.typeArguments);
            }
            break;
        }
        case ts.SyntaxKind.AsExpression: {
            const n = node;
            children.push(n.expression, n.type);
            break;
        }
        case ts.SyntaxKind.NonNullExpression: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.TemplateSpan: {
            const n = node;
            children.push(n.expression, n.literal);
            break;
        }
        case ts.SyntaxKind.SemicolonClassElement: {
            const n = node;
            if (n.name) {
                children.push(n.name);
            }
            break;
        }
        case ts.SyntaxKind.Block: {
            const n = node;
            children.push(...n.statements);
            break;
        }
        case ts.SyntaxKind.VariableStatement: {
            const n = node;
            children.push(n.declarationList);
            break;
        }
        case ts.SyntaxKind.ExpressionStatement: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.IfStatement: {
            const n = node;
            pushall(children, n.expression, n.thenStatement, n.elseStatement);
            break;
        }
        case ts.SyntaxKind.DoStatement: {
            const n = node;
            children.push(n.expression, n.statement);
            break;
        }
        case ts.SyntaxKind.WhileStatement: {
            const n = node;
            children.push(n.expression, n.statement);
            break;
        }
        case ts.SyntaxKind.ForStatement: {
            const n = node;
            pushall(children, n.initializer, n.condition, n.incrementor, n.statement);
            break;
        }
        case ts.SyntaxKind.ForInStatement: {
            const n = node;
            children.push(n.initializer, n.expression, n.statement);
            break;
        }
        case ts.SyntaxKind.ForOfStatement: {
            const n = node;
            children.push(n.initializer, n.expression, n.statement);
            break;
        }
        case ts.SyntaxKind.ContinueStatement: {
            const n = node;
            if (n.label) {
                children.push(n.label);
            }
            break;
        }
        case ts.SyntaxKind.BreakStatement: {
            const n = node;
            if (n.label) {
                children.push(n.label);
            }
            break;
        }
        case ts.SyntaxKind.ReturnStatement: {
            const n = node;
            if (n.expression) {
                children.push(n.expression);
            }
            break;
        }
        case ts.SyntaxKind.WithStatement: {
            const n = node;
            children.push(n.expression, n.statement);
            break;
        }
        case ts.SyntaxKind.SwitchStatement: {
            const n = node;
            children.push(n.expression, n.caseBlock);
            break;
        }
        case ts.SyntaxKind.LabeledStatement: {
            const n = node;
            children.push(n.label, n.statement);
            break;
        }
        case ts.SyntaxKind.ThrowStatement: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.TryStatement: {
            const n = node;
            pushall(children, n.tryBlock, n.catchClause, n.finallyBlock);
            break;
        }
        case ts.SyntaxKind.VariableDeclaration: {
            const n = node;
            pushall(children, n.name, n.type, n.initializer);
            break;
        }
        case ts.SyntaxKind.VariableDeclarationList: {
            const n = node;
            children.push(...n.declarations);
            break;
        }
        case ts.SyntaxKind.FunctionDeclaration: {
            const n = node;
            pushall(children, n.name, n.body, n.type, ...n.parameters);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            break;
        }
        case ts.SyntaxKind.ClassDeclaration: {
            const n = node;
            pushall(children, n.name, ...n.members);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            if (n.heritageClauses) {
                children.push(...n.heritageClauses);
            }
            break;
        }
        case ts.SyntaxKind.InterfaceDeclaration: {
            const n = node;
            children.push(n.name, ...n.members);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            if (n.heritageClauses) {
                children.push(...n.heritageClauses);
            }
            break;
        }
        case ts.SyntaxKind.TypeAliasDeclaration: {
            const n = node;
            children.push(n.name, n.type);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            break;
        }
        case ts.SyntaxKind.EnumDeclaration: {
            const n = node;
            children.push(n.name, ...n.members);
            break;
        }
        case ts.SyntaxKind.ModuleDeclaration: {
            const n = node;
            pushall(children, n.name, n.body);
            break;
        }
        case ts.SyntaxKind.ModuleBlock: {
            const n = node;
            children.push(...n.statements);
            break;
        }
        case ts.SyntaxKind.CaseBlock: {
            const n = node;
            children.push(...n.clauses);
            break;
        }
        case ts.SyntaxKind.NamespaceExportDeclaration: {
            const n = node;
            yield* walkMostAST(n.name);
            break;
        }
        case ts.SyntaxKind.ImportEqualsDeclaration: {
            const n = node;
            children.push(n.name, n.moduleReference);
            break;
        }
        case ts.SyntaxKind.ImportDeclaration: {
            const n = node;
            pushall(children, n.importClause, n.moduleSpecifier);
            break;
        }
        case ts.SyntaxKind.ImportClause: {
            const n = node;
            pushall(children, n.name, n.namedBindings);
            break;
        }
        case ts.SyntaxKind.NamespaceImport: {
            const n = node;
            children.push(n.name);
            break;
        }
        case ts.SyntaxKind.NamedImports: {
            const n = node;
            children.push(...n.elements);
            break;
        }
        case ts.SyntaxKind.ImportSpecifier: {
            const n = node;
            pushall(children, n.propertyName, n.name);
            break;
        }
        case ts.SyntaxKind.ExportAssignment: {
            const n = node;
            pushall(children, n.name, n.expression);
            break;
        }
        case ts.SyntaxKind.ExportDeclaration: {
            const n = node;
            pushall(children, n.exportClause, n.moduleSpecifier, n.name);
            break;
        }
        case ts.SyntaxKind.NamedExports: {
            const n = node;
            children.push(...n.elements);
            break;
        }
        case ts.SyntaxKind.ExportSpecifier: {
            const n = node;
            pushall(children, n.propertyName, n.name);
            break;
        }
        case ts.SyntaxKind.MissingDeclaration: {
            const n = node;
            if (n.name) {
                children.push(n.name);
            }
            break;
        }
        case ts.SyntaxKind.ExternalModuleReference: {
            const n = node;
            pushall(children, n.expression);
            break;
        }
        case ts.SyntaxKind.JsxElement: {
            const n = node;
            children.push(n.openingElement, n.closingElement, ...n.children);
            break;
        }
        case ts.SyntaxKind.JsxSelfClosingElement: {
            const n = node;
            yield* walkMostAST(n.tagName);
            for (const property of n.attributes.properties) {
                yield* walkMostAST(property);
            }
            break;
        }
        case ts.SyntaxKind.JsxOpeningElement: {
            const n = node;
            yield* walkMostAST(n.tagName);
            yield* walkMostAST(n.attributes);
            break;
        }
        case ts.SyntaxKind.JsxClosingElement: {
            const n = node;
            children.push(n.tagName);
            break;
        }
        case ts.SyntaxKind.JsxAttribute: {
            const n = node;
            pushall(children, n.name, n.initializer);
            break;
        }
        case ts.SyntaxKind.JsxSpreadAttribute: {
            const n = node;
            children.push(n.expression);
            break;
        }
        case ts.SyntaxKind.JsxExpression: {
            const n = node;
            if (n.expression) {
                children.push(n.expression);
            }
            break;
        }
        case ts.SyntaxKind.CaseClause: {
            const n = node;
            children.push(n.expression, ...n.statements);
            break;
        }
        case ts.SyntaxKind.DefaultClause: {
            const n = node;
            children.push(...n.statements);
            break;
        }
        case ts.SyntaxKind.HeritageClause: {
            const n = node;
            if (n.types) {
                children.push(...n.types);
            }
            break;
        }
        case ts.SyntaxKind.CatchClause: {
            const n = node;
            children.push(n.variableDeclaration, n.block);
            break;
        }
        case ts.SyntaxKind.PropertyAssignment: {
            const n = node;
            children.push(n.name, n.initializer);
            break;
        }
        case ts.SyntaxKind.ShorthandPropertyAssignment: {
            const n = node;
            pushall(children, n.name, n.objectAssignmentInitializer);
            break;
        }
        case ts.SyntaxKind.EnumMember: {
            const n = node;
            pushall(children, n.name, n.initializer);
            break;
        }
        case ts.SyntaxKind.SourceFile: {
            const n = node;
            children.push(...n.statements);
            break;
        }
        case ts.SyntaxKind.JSDocTypeExpression: {
            const n = node;
            children.push(n.type);
            break;
        }
        case ts.SyntaxKind.JSDocArrayType: {
            const n = node;
            children.push(n.elementType);
            break;
        }
        case ts.SyntaxKind.JSDocUnionType: {
            const n = node;
            children.push(...n.types);
            break;
        }
        case ts.SyntaxKind.JSDocTupleType: {
            const n = node;
            children.push(...n.types);
            break;
        }
        case ts.SyntaxKind.JSDocNullableType: {
            const n = node;
            children.push(n.type);
            break;
        }
        case ts.SyntaxKind.JSDocNonNullableType: {
            const n = node;
            children.push(n.type);
            break;
        }
        case ts.SyntaxKind.JSDocRecordType: {
            const n = node;
            children.push(n.literal);
            break;
        }
        case ts.SyntaxKind.JSDocRecordMember: {
            const n = node;
            pushall(children, n.name, n.type, n.initializer);
            break;
        }
        case ts.SyntaxKind.JSDocTypeReference: {
            const n = node;
            children.push(n.name, ...n.typeArguments);
            break;
        }
        case ts.SyntaxKind.JSDocOptionalType: {
            const n = node;
            children.push(n.type);
            break;
        }
        case ts.SyntaxKind.JSDocFunctionType: {
            const n = node;
            pushall(children, n.name, n.type, ...n.parameters);
            if (n.typeParameters) {
                children.push(...n.typeParameters);
            }
            break;
        }
        case ts.SyntaxKind.JSDocVariadicType: {
            const n = node;
            children.push(n.type);
            break;
        }
        case ts.SyntaxKind.JSDocConstructorType: {
            const n = node;
            children.push(n.type);
            break;
        }
        case ts.SyntaxKind.JSDocThisType: {
            const n = node;
            children.push(n.type);
            break;
        }
        case ts.SyntaxKind.JSDocComment: {
            const n = node;
            if (n.tags) {
                children.push(...n.tags);
            }
            break;
        }
        case ts.SyntaxKind.JSDocTag: {
            const n = node;
            children.push(n.tagName);
            break;
        }
        case ts.SyntaxKind.JSDocParameterTag: {
            const n = node;
            pushall(children, n.typeExpression, n.postParameterName, n.parameterName);
            if (n.preParameterName) {
                children.push(n.preParameterName);
            }
            break;
        }
        case ts.SyntaxKind.JSDocReturnTag: {
            const n = node;
            children.push(n.typeExpression);
            break;
        }
        case ts.SyntaxKind.JSDocTypeTag: {
            const n = node;
            children.push(n.typeExpression);
            break;
        }
        case ts.SyntaxKind.JSDocTemplateTag: {
            const n = node;
            children.push(...n.typeParameters);
            break;
        }
        case ts.SyntaxKind.JSDocTypedefTag: {
            const n = node;
            pushall(children, n.fullName, n.typeExpression, n.jsDocTypeLiteral);
            if (n.name) {
                children.push(n.name);
            }
            break;
        }
        case ts.SyntaxKind.JSDocPropertyTag: {
            const n = node;
            children.push(n.name, n.typeExpression);
            break;
        }
        case ts.SyntaxKind.JSDocTypeLiteral: {
            const n = node;
            if (n.jsDocPropertyTags) {
                children.push(...n.jsDocPropertyTags);
            }
            if (n.jsDocTypeTag) {
                children.push(n.jsDocTypeTag);
            }
            break;
        }
        case ts.SyntaxKind.JSDocLiteralType: {
            const n = node;
            children.push(n.literal);
            break;
        }
        case ts.SyntaxKind.SyntaxList: {
            const n = node;
            children.push(...n._children);
            break;
        }
        default:
            break;
    }
    for (const child of children) {
        if (child) {
            yield* walkMostAST(child);
        }
    }
}
exports.walkMostAST = walkMostAST;
function pushall(arr, ...elems) {
    for (const e of elems) {
        if (e) {
            arr.push(e);
        }
    }
    return arr.length;
}
//# sourceMappingURL=ast.js.map